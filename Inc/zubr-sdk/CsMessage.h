/*
   Проект "Серводвигатель для роботов Zubr"
   Автор
     Сибилев А.С.
   Описание
     StMessageZubr - реализация протокола сообщений с сервомашиной собственной
 разработки Zubr

     Учитывая требования высокой скорости передачи, прежние алгоритмы приема и
 отправки сообщений включая их детектирование - не годятся. Используемая система
 работы по прерываниям не успевает обработать поступающие байты. Было принято
 решение задействовать систему dma.

     Для системы приема по dma характерна необходимость заранее знать
 длительность данных, что в условиях протокола переменной длины не возможно.
 Поэтому прием ведется в кольцевой буфер постоянно, а программа в своем темпе
 пытается анализировать принятые данные. В этой связи актуальным делается вопрос
 обозначения начала фрейма (посылки, сообщения). Прежняя система детектирования
 пауз между посылками представляется нереальной для реализации. Было принято
     решение старший бит в байтах отдать под сигнал команда-данные. Это решает
 вопрос с определением начала посылки, но несколько усложняет упаковку данных.

     Таким образом сообщение теперь представляет собой посылку битов,
 упакованных в байты таким образом, что первый байт сообщения имеет в старшем
 бите 0, а остальные байты сообщения имеют в старшем бите 1.

     На передачу
       - заголовок: код команды и идентификатор двигателя
       - данные: один или несколько байтов данных
     На прием
       - заголовок:  код команды и идентификатор двигателя
       - данные: один или несколько байтов данных

       Заголовок
       7 6 5 4  3 2 1 0
       0 -cmd-  --id---

       Команды cmd:
       0 - команда управления, отправка данных воздействия 16бит и получение
 данных состояния 2*16бит 1 - получить данные состояния 3*16бит 2 - резерв
       3
       4
       5 - записать параметр, индекс параметра 16бит, значение параметра 32бит
       6 - прочитать параметр, индекс параметра 16бит
       7 - прошивка, адрес прошивки 32бит, данные прошивки 32бит

       Идентификатор мотора id. Поддерживается 15 двигателей. Двигатель с id = 0
 значение по сбросу, двигатель с id = 15 универсальный идентификатор для
 прошивки

       [0] Команда управления:
         Заголовок, Воздействие 2 байт, КС
       ответ
         Текущий угол 2 байт, текущий момент 2 байт, КС

       [1] Получить данные состояния
         Заголовок, КС
       ответ
         3*16 значений состояния, КС

       [5] Записать параметр:
         Заголовок, Индекс параметра (2байт), Параметр (4байта), КС
       ответ
         Параметр (4байта), КС

       [6] Прочитать параметр:
         Заголовок, Индекс параметра (2байт), КС
       ответ
         Параметр (4байта), КС

       [7] Прошивка
         В режиме прошивки заголовок равен 0x7f
         Заголовок 4 байта адрес, 4 байта слово, КС
       ответ
         1 байт - идентификатор устройства, в старших битах которого код ошибки
 или 0, если ошибок нету 0000 -id- в поле id возвращается идентификатор
 устройства
                   -+-
                    +------ код состояния (0-7)
                            0 - нету ошибок
         4 байта   значение или адрес





   Учитывая, что один из вариантов обмена с хостом - это uart, то целесообразно
   унифицировать обмен между хостом и контроллером.
   Поскольку контроллер один и различие по идентификатору не требуется, решено
   отдать под код команды весь заголовок.

       Заголовок
       7 6 5 4  3 2 1 0
       0 ----cmd-------

   Конкретные коды команд и состав посылок представлены в файле roboComBook.h

 История
   12.01.2023  v1 начал вести версии
   */

#include <stdint.h>

namespace Zubr {

inline int csMessageId(char ch) { return ch & 0xf; }
inline int csMessageCmd(char ch) { return (ch >> 4) & 0x7; }

template <int len> struct CsMessageBuf {
  const int mSize = len; //!< Константный размер буфера
  char mBuffer[len]; //!< Буфер, содержащий принятый блок данных
  int mLength; //!< Количество данных в буфере

  CsMessageBuf() : mLength(0) {}
};

using CsMessageBuf256 = CsMessageBuf<256>;

class CsMessageOut {
  char mBuffer[64]; //! Буфер для размещения закодированных данных
  int mPtr;         //! Номер текущего байта
  int mUsedBits; //! Количество свободных битов в текущем байте
public:
  CsMessageOut() : mPtr(0), mUsedBits(0) {}

  //!
  //! \brief addIntN Добавить N-битное значение
  //! \param val     Значение
  //! \param bits    Количество бит значения
  //!
  void addIntN(int val, int bits);

  //!
  //! \brief addInt8 Добавить 8-битное значение
  //! \param val 8-битное значение
  //!
  void addInt8(int val);

  //!
  //! \brief addInt7 Добавить 7-битное значение
  //! \param val     7-битное значение
  //!
  void addInt7(int val);

  //   template <int size>
  //   void addIntL7( int val )
  //     {
  //     //Удаляем старшие биты
  //     val &= 0x7f >> (7-size);
  //     if( size + mUsedBits < 7 ) {
  //       mBuffer[mPtr] |= (val << mUsedBits) | 0x80;
  //       mUsedBits += size;
  //       }
  //     else {
  //       //Добавляем биты в текущий байт
  //       mBuffer[mPtr++] |= (val << mUsedBits) | 0x80;

  //       //Количество битов добавленных выше
  //       int bits = 7 - mUsedBits;

  //       //Количество использованных битов в новом байте
  //       mUsedBits = size - bits;
  //       mBuffer[mPtr] = (val >> bits) | 0x80;
  //       if( mUsedBits == 7 ) {
  //         mPtr++;
  //         mBuffer[mPtr] = 0;
  //         mUsedBits = 0;
  //         }
  //       }
  //     }

  //!
  //! \brief addInt16 Добавить 16-битное значение
  //! \param val 16-битное значение
  //!
  void addInt16(int val);

  //!
  //! \brief addInt32 Добавить 32-битное значение
  //! \param val 32-битное значение
  //!
  void addInt32(int val);

  //!
  //! \brief addFloat Добавить 32-битное с плавающей точкой
  //! \param val      32-битное с плавающей точкой
  //!
  void addFloat(float val);

  //!
  //! \brief addBlock Добавить блок байтов
  //! \param block    Блок байтов
  //! \param size     Размер блока
  //!
  void addBlock(const char *block, int size);

  //!
  //! \brief beginQuery Инициализация буфера командой cmd. После инициализации
  //! можно добавлять данные \param cmd        Формируемая команда \param id
  //! Идентификатор устройства, которому адресована данная команда
  //!
  void beginQuery(char cmd, int id);

  //!
  //! \brief beginAnswer Инициализация буфера для ответа. После инициализации
  //! можно добавлять данные
  //!
  void beginAnswer();

  //!
  //! \brief hostBeginQuery Инициализация буфера командой cmd. После
  //! инициализации можно добавлять данные \param cmd            Формируемая
  //! команда
  //!
  void hostBeginQuery(char cmd);

  //!
  //! \brief hostBeginAnswer Инициализация буфера для ответа. После
  //! инициализации можно добавлять данные
  //!
  void hostBeginAnswer() { beginAnswer(); }

  //!
  //! \brief hostEnd Завершение формирования команды, дописывание контрольной
  //! суммы и символа \n
  //!
  void hostEnd();

  //!
  //! \brief end Завершение формирования команды и дописывание контрольной суммы
  //!
  void end();

  //!
  //! \brief lenght Возвращает текущую заполненную длину буфера
  //! \return       Длина заполненной части буфера
  //!
  int length() const { return mPtr; }

  //!
  //! \brief buffer Возвращает буфер с сформированной строкой. Строка имеет
  //! завершающий символ \n и 0 на конце. \return Указатель на начало буфера
  //!
  const char *buffer() const { return mBuffer; }

  //==================================================================
  //  Комплексные операции
  //!
  //! \brief makeQueryControl Сформировать команду "Управление"
  //! \param id               Идентификатор устройства
  //! \param value            Значение управления
  //!
  void makeQueryControl(int id, int value);

  void makeQueryControlEx(int id, int value, int reserv16);

  //!
  //! \brief makeAnswerControl Сформировать ответ на команду "Управление"
  //! \param angle             Текущий угол сервы
  //! \param moment            Текущий момент
  //!
  void makeAnswerControl(int angle, int moment);

  void makeAnswerControlEx(int angle, int pwm, int velo, int reserv8,
                           int flags);

  //!
  //! \brief makeQueryInfo Сформировать команду "Получить информацию"
  //! \param id            Идентификатор устройства
  //!
  void makeQueryInfo(int id);

  //!
  //! \brief makeAnswerInfo  Сформировать ответ на команду "Получить информацию"
  //! \param val0            Значение 0
  //! \param val1            Значение 1
  //! \param val2            Значение 2
  //!
  void makeAnswerInfo(int val0, int val1, int val2);

  //!
  //! \brief makeQueryWrite Сформировать команду "Запись параметра"
  //! \param id             Идентификатор устройства
  //! \param index          Индекс параметра
  //! \param value          Значение параметра
  //!
  void makeQueryWrite(int id, int index, int value);

  //!
  //! \brief makeAnswerWrite Сформировать ответ на команду "Запись параметра"
  //! \param value           Значение, записанное в параметр
  //!
  void makeAnswerWrite(int value);

  //!
  //! \brief makeQueryRead Сформировать команду "Чтение параметра"
  //! \param id            Идентификатор устройства
  //! \param index         Индекс параметра
  //!
  void makeQueryRead(int id, int index);

  //!
  //! \brief makeAnswerRead Сформировать ответ на команду "Чтение параметра"
  //! \param index          Индекс параметра
  //! \param value          Значение параметра
  //!
  void makeAnswerRead(int value);

  //!
  //! \brief makeQueryFlash Сформировать команду "Прошивка"
  //! \param id             Идентификатор устройства
  //! \param adrOrCmd       Адрес прошивки или команда
  //! \param value          Значение прошивки
  //!
  void makeQueryFlash(int id, int adrOrCmd, int value);

  //!
  //! \brief crc  Вычисление контрольной суммы для блока данных
  //! \param buf  Буфер с данными, на которых вычисляется контрольная сумма
  //! \param size Размер данных в байтах
  //! \return     Контрольная сумма
  //!
  static int crc(const char *buf0, int size0, const char *buf1 = nullptr,
                 int size1 = 0);
};

//!
//! \brief The CsMessageIn class служит для преобразования сообщения в бинарные
//! данные. Для кодирования служит класс CsMessageOut. Кодирование и
//! декодирование полностью согласованы, поэтому нечувствительны к различиям
//! используемых платформ. Данный класс поддерживает циклический буфер.
//!
class CsMessageIn {
  const char *mBuffer; //!< Указатель на циклический буфер
  int mStart; //!< Индекс начала данных в циклическом буфере
  int mBufSize; //!< Размер циклического буфера
  int mPtr; //!< Номер текущего байта декодируемого сообщения
  int mUsedBits; //!< Количество использованных битов в текущем байте

  char at(int index) const {
    index += mStart;
    return mBuffer[index < mBufSize ? index : index - mBufSize];
  }

public:
  //!
  //! \brief SvTextStreamIn Конструктор декодера
  //! \param buf Буфер, содержащий исходную строку
  //!
  CsMessageIn(const char *buf, short start, short size = 0x7fff, int ptr = 0);

  template <class CsMessageBufTmpl>
  CsMessageIn(CsMessageBufTmpl &buf, int ptr = 0)
      : mBuffer(buf.mBuffer), mStart(0), mBufSize(buf.mSize), mPtr(ptr),
        mUsedBits(0) {}

  //!
  //! \brief id Возвращает идентификатор устройства, которому адресовано
  //! сообщение \return   Идентификатор устройства
  //!
  int id() const { return csMessageId(at(0)); }

  //!
  //! \brief cmd Возвращает команду сообщения
  //! \return    Команда сообщения
  //!
  int cmd() const { return csMessageCmd(at(0)); }

  //!
  //! \brief hostCmd Возвращает команду сообщения от хоста
  //! \return        Команда сообщения
  //!
  int hostCmd() const { return at(0); }

  //!
  //! \brief reset Установить новое начало данных и сбросить номер текущего
  //! байта и счетчик битов \param start Индекс начала новых данных \param ptr
  //! Индекс, с которого начинаем декодирование
  //!
  void reset(int start, int ptr);

  //!
  //! \brief getUInt8 Извлекает 8-битное число предполагая, что оно беззнаковое
  //! \return         8-битное число
  //!
  int getUInt8();

  //!
  //! \brief getInt8 Извлекает 8-битное число
  //! \return        8-битное число со знаком
  //!
  int getInt8();

  //!
  //! \brief getUInt7 Извлекает 7-битное число
  //! \return         7-битное число без знака
  //!
  int getUInt7();

  //!
  //! \brief getUInt16 Извлекает 16-битное число предполагая, что оно
  //! беззнаковое \return          16-битное число
  //!
  int getUInt16();

  //!
  //! \brief getInt16 Извлекает 16-битное число со знаком
  //! \return         16-битное число со знаком
  //!
  int getInt16();

  //!
  //! \brief getInt32 Извлекает 32-битное число
  //! \return 32-битное число
  //!
  int getInt32();

  //!
  //! \brief getBlock Извлекает набор байтов
  //! \param dest Буфер-приемник байтов
  //! \param size Количество извлекаемых байтов
  //!
  void getBlock(char *dest, int size);

  //!
  //! \brief checkCrc Проверить совпадение контрольной суммы
  //! \param length   Длина сообщения
  //! \return         true когда контрольная сумма совпала
  //!
  bool checkCrc(int length) const;
};

//!
//! \brief floatToUInt Упаковка числа с плавающей точкой в тридцатидвухразрядную
//! ячейку \param val         Число с плавающей точкой \return Упакованное число
//! с плавающей точкой
//!
inline uint32_t floatToUInt(float val) {
  // We need to do this in order to access the bits from our float
  uint32_t *u = reinterpret_cast<uint32_t *>(&val);
  return *u;
}

//!
//! \brief floatFromUInt Распаковка из тридцатидвухразрядной ячейки в число с
//! плавающей точкой \param val           Упакованное число с плавающей точкой
//! \return              Число с плавающей точкой
//!
inline float floatFromUInt(uint32_t val) {
  float *f = reinterpret_cast<float *>(&val);
  return *f;
}

} // namespace Zubr